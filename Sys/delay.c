#include "delay.h"
/**
******************************************************************************
* @file    delay.c
* @author  JKk
* @date    2018/10/24
* @brief   使用系统滴答进行精确延时功能
******************************************************************************
*/
/********************
函数名：    delay_ms
函数参数：  u16 ms :需要延时时间 以ms为单位
函数返回值：无
函数功能：  实现滴答定时器的ms级别的延时
函数描述：
*********************/
void SysTick_delay_ms(u16 ms)
{
	SysTick->CTRL &=~(0x1<<2);	//选择时钟(外部的时钟)
	SysTick->LOAD = 21000*ms;	//写入自动重装载值
	SysTick->VAL=0;				//清空当前数值寄存器
	SysTick->CTRL |=(0x1<<0);	//打开定时器开始递减计数
	while((SysTick->CTRL & (1<<16))==0);//等待当前数值计数器递减到0
	SysTick->CTRL &=(0x1<<0);	//等待完成以后一次滴答计时结束关闭定时器
}

/********************
函数名：    delay_us
函数参数：  u32 us :需要延时时间 以us为单位
函数返回值：无
函数功能：  实现滴答定时器的us级别的延时
函数描述：
*********************/
void SysTick_delay_us(u32 us)
{
	SysTick->CTRL &=~(0x1<<2);//选择时钟(外部的时钟)
	SysTick->LOAD = 21*us;		//写入自动重装载值  /*    21/21000000 = 1us   */
	SysTick->VAL=0;				//清空当前数值寄存器
	SysTick->CTRL |=(0x1<<0);	//打开定时器开始递减计数
	while((SysTick->CTRL & (1<<16))==0);//等待当前数值计数器递减到0
	SysTick->CTRL &=(0x1<<0);	//等待完成以后一次滴答计时结束关闭定时器
}

//以500ms的延时为基准延时
void SysTick_delay_xms(u32 xms)
{
	u16 i =0;//延时的倍数循环变量	
	for(i=0; i<xms/500; i++)//计算整数个基准延时
	{
		SysTick_delay_ms(500);
	}
	if(xms%500!=0)//如果不是整数倍 有剩余的延时  //有余数
	{
		SysTick_delay_ms(xms%500);
	}
	
}




